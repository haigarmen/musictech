Introduction

The objective of this course is to provide computer programmers with a thorough understanding of sound and music—and of the digital representation of those phenomena—that will help them to program more effectively for sound and music applications.

Digital audio and computer music are deep and complex subjects that require knowledge of other diverse fields such as:
• Acoustics and psychoacoustics
• Cognitive science
• Mathematics
• Digital signal processing
• Computer programming
• User interface design
• Music theory
• Music composition

This class will be structured differently from many lecture classes. Although there will be many specific topics and assignments chosen by the professor, overall each student is responsible for defining her/his learning goals and pursuing those goals using a combination of available resources: online lessons and video, articles, online programming tutorials and documentation, consulting with the professor and the teaching assistants, and consulting with fellow students. In short, each student is responsible for defining and pursuing the things s/he wants to learn about audio and music programming, and for finding the best way to learn those things. In that sense, the members of the class are encouraged to think of themselves as a collaborative team of like-minded researchers.

Topics covered in the class may include:
• Fundamentals of music theory
• Fundamentals of how digital audio works
• MIDI (Musical Instrument Digital Interface)
• Interface and design issues in audio and music software
• Programming audio in Max/MSP
• Programming audio in HTML 5 with the Web Audio API
• Managing audio and MIDI file formats
• Managing I/O streams
• Additive synthesis and wavetable synthesis
• Linear and cubic interpolation
• Control functions and low-frequency oscillators for frequency and amplitude modulation
• Windows and envelopes in the time domain
• Sampling synthesis
• Granular synthesis
• Delay, flanging, chorusing, reverberation, and other delay-based processing techniques
• Filtering and convolution
• Panning, localization, and spatialization
• Amplitude compression and expansion
• Fourier analysis and resynthesis, cross-synthesis, and time compression/expansion

Activities will include:
• Listening and analysis of musical uses of digital audio processing
• Reading and research on theoretical and practical issues of computer audio and music
• Lectures on theoretical issues of computer music synthesis and processing
• Demonstrations of audio and music programming in Web Audio and in Max/MSP, and some discussion of application of those concepts in Java or C
• Collaborative student-designed research/implementation projects
• Writing documentation that summarizes a specific topic in computer audio/music, and describing the research, design, and programming for a specific implementation

Programming languages:

There are many levels at which one might study audio and music programming, from the conceptual to the minute, from a high-level domain-specific language to low-level manipulation of bytes and bits. In this course we will focus on one fairly high-level graphical programming language intended specifically for audio and music (and multimedia) programming: the Max environment by Cycling ’74. We will also implement audio software in JavaScript using the Web Audio API. We may look briefly at some other music programming languages such as Pd, ChucK, SuperCollider, and Csound, and students are welcome to use those languages, but they won’t be a main topic of discussion in class. The intent is to address the topics of sound and music as directly as possible, hindered as little as possible by low-level programming concerns, interface aesthetics, or other extraneous programming issues.

Concepts and techniques implemented in Max will generally have corresponding implementations in Web Audio, and in a more general language such as C or Java, and students will be expected to explore those implementations on their own as a major activity of the course. Students familiar with application programming for iOS in Objective C or for Android in Java are encouraged to use those platforms for implementation if desired; however, the primary focus will be on programming for standard desktop operating systems. In fact, the class sessions will be mostly about concepts and techniques; the actual implementation will in many cases be left up to the students to discover.

Course Requirements:

An attendance record of 90% or better is required to pass the class. Please make every effort to arrive on time. Arrival more than 20 minutes late will be considered 1/2 absence; arrival more than 40 minutes late will be considered a full absence.

Students should attend each class session having done the assigned work—readings, listenings, research, and preparation of presentations—and ready to participate actively in discussion.

Students will be responsible for demonstrating their completion of the assigned studies by successfully answering a short weekly quiz.

Students will complete some short programming assignments, which will be evaluated on program correctness and functionality, thorough fulfillment of the stated requirements, and demonstrated effort.

By the end of the quarter, students working in small collaborative teams of two or three will have researched some specific aspect of audio or music programming and will have completed a program that performs a useful and/or interesting task demonstrating that research. The research, programming, and functionality will be summarized in an article of 2000-3000 words containing an overview of the research topic, the design specification of the program, and basic user documentation.

Final:

There will be no final examination for this class. Quizzes will be scheduled during class sessions or online. A final presentation of the projects will be held during the final week of class and during final exam week.

Grading:

In light of the collaborative and exploratory structure of the class, and the large degree to which student activities are self-determined, a clearly-defined grading percentage system cannot be formulated in advance. In this class grading is mostly a necessary evil—to serve as an incentive for hard work and to maintain a high standard of scholarship. It’s hoped that the students, who have elected to take this course, will work hard out of dedication to learning and developing skills in programming. Each student will thus be expected to work at the level—and with the tools—appropriate to her/his programming experience and specific interests. In that spirit, students will be graded on their demonstrated initiative and effort, on program correctness and efficacy, and on clarity and completeness in all assigned work.

Communication:

Students, professor, and teaching assistant will stay in continuous contact through a wide range of methods described in detail on the Canvas Communications page. Discussion outside of class will be largely done via the Canvas Discussions.

Disability

If you have a disability that inhibits you from performing any of the stated requirements of this course, as approved and documented by the UCI Disability Services CenterLinks to an external site., please ensure that the professor is thoroughly aware of the matter as early in the term as possible.

Academic Honesty:

Collaboration between students in this course is strongly encouraged. Students are urged to exchange ideas, opinions, and information constantly, and to help each other with the research and programming projects. However, each student is responsible for completion of his/her own assignments.

Plagiarism of any kind is in direct violation of the UCI policy on Academic IntegrityLinks to an external site., and penalties for plagiarism can be severe. In this class you will be expected to attribute due credit to the originator of any ideas, words, programming code, or other ideas that you incorporate into your own work. Any borrowed text must be cited in proper academic bibliographic fashion, giving credit to its original author. Any borrowed computer programming code must be cited in inline commentary in the code, and in any documentation written about the code, giving credit to its original author.

In computer programming, it’s common to use program components that are known to be reliable, written by others. A lot of good (and some bad) program code is freely available. Nevertheless, one must always give full attribution to the original author of all program code.
